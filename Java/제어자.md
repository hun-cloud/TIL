# 제어자(modifier)
제어자는 클래스, 변수 또는 메서드의 선언부에 함꼐 사용되어 부가적인 의미를 부여한다.   
제어자의 종류는 크게 접근 제어자와 그 외의 제어자로 나눌 수 있다.
```
접근 제어자 public, protected, default, private
그      외 static, final, abstract, native, transient, synchronized, volatile, strictfp
```

## static - 클래스의, 공통적인
static이 붙은 멤버변수와 메서드, 그리고 초기화 블럭은 인스턴스가 아닌 클래스에 관계된 것이기 때문에 인스턴스를
생성하지 않고도 사용할 수 있다.


### static 멤버변수
- 모든 인스턴스에 공통적으로 사용되는 클래스변수가 된다.
- 클래스변수는 인스턴스를 생성하지 않고도 사용 가능하다.
- 클래스가 메모리에 로드될 떄 생성된다.

### static 메서드
- 인스턴스를 생성하지 않고도 호출이 가능한 static 메서드가 된다.
- static메서드 내에서는 인스턴스 멤버를 직접 사용할 수 없다.

## final - 마지막의, 변경될 수 없는
final은 '마지막의' 또는 '변경될 수 없는' 의미를 가지고 있으며 거의 모든 대상에 사용될 수 있다.

### final 클래스
- 변경될 수 없는 클래스, 확장될 수 없는 클래스가 된다.
- final로 지정된 클래스는 다른 클래스의 조상이 될 수 없다.

### final 메서드
- 변경될 수 없는 메서드
- final로 지정된 메서드는 오버라이딩을 통해 재정의 될 수 없다.

### final 멤버변수
- 변수 앞에 final이 붙으면, 값을 변경할 수 없는 상수가 된다.

### final 지역변수
- 변수 앞에 final이 붙으면, 값을 변경할 수 없는 상수가 된다.

## abstract - 추상의, 미완성의
abstract는 '미완성'의 의미를 가지고 있다. 메서드의 선언부만 작성하고 실제 수행내용은 구현하지 않은
추상메서드를 선언하는데 사용된다.

- abstract 클래스 : 클래스 내에 추상 메서드가 선언되어 있음을 의미한다.
- abstract 메서드 : 선언부만 작성하고 구현부가 작성하지 않은 추상 메서드임을 알린다.
추상 클래스는 아직 완성되지 않은 메서드가 존재하는 '미완성 설계도'이므로 인스턴스를 생성할 수 없다.
```java
abstract class AbstractTest { // 추상 클래스 (추상 메서드를 포함한 클래스)
    abstract void move();     // 추상 메서드 (구현부가 없는 메서드)
}
```
다른 클래스가 abstract 클래스를 상속받아서 메서드를 구현한 후에 사용이 가능하다.

## 접근제어자(access modifier)
접근제어자는 클래스, 멤버변수, 메서드, 생성자에 사용되어 해당하는 멤버 또는 클래스를 외부에서 접근하지
못하도록 제한하는 역할을 한다.   
접근 제어자가 default임을 알리기 위해 실제로 default를 붙이지 않는다. 클래스나 멤버변수, 메서드, 생성자에
접근 제어자가 지정되어 있지 않다면, 접근 제어자가 default임을 뜻한다.
```
접근 제어자가 사용될 수 있는 곳 - 클래스, 멤버변수, 메서드, 생성자

private     같은 클래스 내에서만 접근이 가능하다.
default     같은 패키지 내에서만 접근이 가능하다.
protected   같은 패키지 내에서, 그리고 다른 패키지의 자손 클래스에서 접근이 가능하다.
public      접근 제한이 전혀 없다.
```
접근 범위가 넓은 쪽에서 좁은 쪽 순으로 나열하면 다음과 같다.
```
public > protected > (default) > private
```

### 접근 제어자를 이용한 캡슐화
클래스나 멤버, 주로 멤버에 접근 제어자를 사용하는 이유는 클래스의 내부에 선언된 데이터를 보호하기 위해서이다.   
데이터가 유효한 값을 유지하도록, 또는 비밀번호와 같은 데이터를 외부에서 함부로 변경하지 못하도록 하기 위해서
접근을 제한하는 것이 필요하다.
```
접근 제어자를 사용하는 이유
- 외부로부터 데이터를 보호하기 위해서
- 외부에는 불필요한, 내부적으로만 사용되는, 부분을 감추기 위해서
```
* 만일 메서드 하나를 변경해야한다고 가정했을 때

## 제어자의 조합
1. 메서드에 static과 abstract를 함꼐 사용할 수 없다.
- static메서드는 몸통이 있는 메서드에만 사용할 수 있기 때문이다.
2. 클래스에 abstract와 final을 동시에 사용할 수 없다.
- 클래스에 사용되는 final은 클래스를 확장할 수 없다는 의미이고 abstract는 상속을 통해서 완성되야한다는 의미이므로
  서로 모순되기 때문이다.
3. abstract메서드의 접근 제어자가 private일 수 없다.
- abstract메서드는 자손클래스에서 구현해주어야하는데 접근 제어자가 private 이면, 자손 클래스에서 접근할 수 없기 때문이다.
4. 메서드에 private와 final을 같이 사용할 필요는 없다.
- 접근 제어자가 private인 메서드는 오버라이딩 될 수 없기 때문이다. 이 둘 중 하나만 사용해도 의미가 있다.

## native
자바에서 다른 언어를 사용할 수 있게 만들어주는 키워드이다. 운영체제에 깊게 접근하지 못해서 결국에는
운영체제에 깊은 접근이 가능한 언어를 사용하기 위해 JNI를 사용해서 native 키워드를 사용한다.

## volatile
thread에서 사용되는 것인데, cpu cache와 메인메모리에서 read & write상에서의 불일치를 해결하기 위해
사용되는 키워드이다. (성능에 영향을 줄 수 있는 키워드라고 한다.)

## strictfp
자바와 타 플랫폼간의 부동소수점의 정밀도를 맞추기 위한 키워드이다. 다른 플랫폼과는 자바는 부동소수점에서
오차가 발생할 수 있는데 이 키워드를 사용하면 해결된다.




출처 : [자바의 정석 남궁성]
