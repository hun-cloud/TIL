# 연산자
연산자란 '연산을 수행하는 기호'를 말한다.

## 연산자와 피연산자
```
연산자 (operator) : 연산을 수행하는 기호 (+,-,*,/ 등)
피연산자 (operand) : 연산자의 작업 대상 (변수, 상수, 리터럴, 수식)
```

## 식과 대입연산자
```java
4 * x + 3; // 이 값은 어디에도 사용되지 않고 사라진다.

y = 4 * 5 + 3; // 대입연산자 '='를 사용해서 변수와 같이 값을 저장할 수 있는 공간에 결과를 저장해야한다.
```

### 연산자의 종류
- 산술 연산자 : +  -  *  /  %  <<  >>     사칙연산 + 나머지연산
- 비교 연산자 : >  <  >=  <== == !=       크고 작음과 같고 다름을 비교
- 논리 연산자 : &&  ||  !  &  |  ^  ~     그리고와 또는 으로 조건 연결
- 대입 연산자 :         =                 우변의 값을 좌변에 저장
- 기      타 : (type) ? : instanceof     형변환 연산자, 삼항 연산자, instanceof연산자

### 연산자의 우선순위와 결합규칙
```java
1. -x + 3                // 단항연산자, 이항연산자

2. x + 3 * y

3. x + 3 > y - 2        // 비교연산자, 산술연산자

4. x > 3 && x < 5       // 논리연산자, 비교연산자

5. result = x + y * 3;  // 대입연산자

6. x << 2 + 1           // 쉬프트 연산자, 덧셈연산자

7. data & 0xFF == 0         // 비트연산자, 비교연산자

8. x < -1 || x > 3 && x < 5 // 논리연산자 &, && -> |, ||
```
* 하나의 식에 같은 우선순위의 연산자들이 여러 개 있는 경우, 어떤 순서로 연산을 수행하는 규칙을 "연산자의 결합규칙" 이라고 한다.
1. 산술 > 비교 > 논리 > 대입
2. 단항(1) > 이항(2) > 삼항(3) 단항 연산자의 우선순위가 이항 연산자 보다 높다.
3. 단항 연산자와 대입 연산자를 제외한 모든 연산의 진행 방향은 왼쪽에서 오른쪽이다.
   
☆ 연산자와 우선순위와 결합규칙 -> 검색

## 산술 변환
이항 연산자는 두 피연산자의 타입이 일치해야 연산이 가능 하므로, 피 연산자의 타입이 서로 다르다면 연산 전에 형변환 연산자로
타입을 일치 시켜야 한다.
```java
int i = 10;
float f = 20.of;

float result = f + (fluat)i; // 형변환으로 두 피연산자의 타입을 일치
```
대부분의 경우, 두 피연산자의 타입 중에서 더 큰 타입으로 일치시키는데, 그 이유는 작은 타입으로 형변환하면 원래의 값이 손실될
가능성이 있기 떄문이다.   
작은 타입에서 큰 타임으로 형변환하는 경우, 자동적으로 형변환되므로 형변환 연산자를 생략할 수 있다.
```java
float result = f + i; // 큰 타입으로 형 변환시, 형변환 연산자 생략 가능
```
이처럼 자동으로 형변환 되는 것을 '산술 연산' 또는 '일반 산술 변환'이라 하며, 이 변환은 이항 연산자에서만 아니라 단항 연산자에서도 일어난다.
- 산술 변화의 규칙
1. 두 피연산자의 타입을 같게 일치시킨다. (보다 큰 타입으로 일치)
```java
long + int -> long + long

float + int -> float + float

double + float -> double + double
```
2. 피연산자의 타입이 int보다 작은 타입이면 int로 변환된다.
```java
byte + short -> int + int

char + short -> int + int
```
- 첫번쨰 규칙은 피연산자의 값손실을 최소화 하기위한 것
- 두번쨰 규칙은 정수타입인 int가 가장 효율적으로 처리할 수 있는 타입이기 때문에, char 이나 short의 표현 범위가 좁아서
  연산중에 오버플로우가 발생할 가능성이 높기 떄문에 만들어진 것이다.
☆ 연산결과의 타입은 피연산자의 타입과 일치한다.
```java
5 / 2 = 2 // 소숫점은 버려짐
```
```
산술 변환이란? 연산 수행 직전에 발생하는 피연산자의 자동 형변환
1. 두 피연산자의 타입을 같게 일치시킨다.(보다 큰 타입으로 일치)
2. 피연산자의 타입이 int보다 작은 타입이면 int로 변환된다.
```

## 단항 연산자
```
증감 연산자(++) 피연산자의 값을 1 증가시킨다.
감소 연산자(--) 피연산자의 값을 1 감소시킨다.
```
* 증감연산자는 일반 산술 변환에 의한 자동 형변환이 방생하지 않으며, 연산결과의 타입은 피연산 결과의 타입과 같다.
피연산자의 왼쪽에 위치하면 '전위형(prefix)', 오른쪽에 위치하면 '후위형(postfix)'라고 한다.
```
int i = 5, j = 0;
        
j = i++;
        
i = 5; 
j = 0;
        
j = ++i;
```
증감연산자를 사용하면 코드가 간결해지지만, 지나치면 코드가 복잡해져 이해하기 어려워지기도 한다.
식에 두 번 이상 포함된 변수에 증감연산자를 사용하는 것은 피해야한다.   
```java
x = x++ - ++x  // 식이 너무 복잡함
```
감소연산자(--)는 피연산자의 값을 1 감소시킨다는 것만 뺴면 증가 연산자와 동일하다.

## 부호연산자 (+ , -)
부호연산자 '-'는 피연산자의 부호를 반대로 변경한 결과를 반환한다.   
부호연산자 '+'는 하는 일이 없으며, 쓰이는 경우도 거의 없다. 부호연산자 '-'가 있으니까   
형식적으로 '+'를 추가해 놓은 것뿐이다.
```java
int i = -10;
i = +i;
        
i = -10;
i = -i;
```

## 산술연산자 (+, -, *, /, %)

우선순위
```
* -> / -> % -> + -> -
```
피연산자가 정수형인 경우 0으로 나눈다면 실행 시 에러가 발생
```java
System.out.print(3/0);  // 실행 시, 오류(ArithmeticException) 발생
System.out.print(3/0.0); // Infinity 출력
```
```java
byte a = 10;
byte b = 20;
byte c = a + b; // 컴파일 에러 발생 명시적 형변환이 필요 (byte)(a+b);
```

사칙연산의 피연산자로 숫자뿐만 아니라 문자도 가능하다. 문제는 실제로 해당 문자의 유니코드(부호없는 정수)   
로 바뀌어 저장되므로 문자간의 사칙연산은 정수간의 연산과 동일하다. 주로 문자간의 뺄셈을 하는 경우가 대부분이며,   
문자 '2'를 숫자로 변환하려면 다음과 같이 문자 '0'을 뺴주면 된다.
```java
'2' - '0' -> 50 - 48 -> 2
```
| 문자 | 코드 |
|------|------|
|0|48|
|9|57|
|A|65|
|Z|90|
|a|97|
|z|122|
```java
char c1 = 'a';    // c1에는 문자 'a'의 코드값인 97이 저잔된다.
char c2 = c1;     // c1에 저장되어 있는 값이 c2에 저장된다.
char c3 = ' ';    // c3를 공백으로 초기화한다. 참고로 공백은 32 !

int i = c1 + 1 ;  // 97 + 1 = 98
c3 = (char) (c1 + 1) // 'b'
```

```java
char c1 = 'a';          
// char c2 = c1 + 1;       // 컴파일 에러 발생
char c2 = 'a' + 1;      // 컴파일 에러 없음 ?? 왜 에러가 안나는 것일까
System.out.print(c2);   // b
```

'a'+1이 리터럴 간의 연산이기 떄문이다. 상수 또는 리터럴 간의 연산은 실행 과정동안 변하는 값이 아니기 때문에,   
컴파일 시 컴파일러가 계산해서 그 결과로 대체함으로써 코드를 보다 효율적으로 만든다. -> 실행 시에는 이미 결과가 들어가 있다
- 컴파일 전의 코드
```java
char c2 = 'a' + 1;
int sec = 60 * 60 * 24;
```
- 컴파일 후의 코드
```java
char c2 = 'b';
int sec = 96400;
```

## 나머지 연산자 %
나머지 연산자는 왼쪽의 피연산자를 오른쪽 피연산자로 나누고 난 나머지 값을 결과로 반환하는 연산자이다.   
오른쪽 연산자로 0을 사용할 수 없다.
```java
System.out.print(-10%8);   // -2
System.out.print(10%-8);   // 2
System.out.print(-10%-8);  // -2
```
피연산자의 부호는 모두 무시하고, 나머지 연산을 한 결과에 왼쪽 피연산자의 부호를 붙이면 된다.

## 비교 연산자
두 피연산자를 비교하는데 사용되는 연산자이다. 주로 조건문과 반복문의 조건식에 사용되며, 연산결과는 오직   
true와 false 둘 중 하나이다.   
이항 연산자이므로 비교하는 피연산자의 타입이 서로 다를 경우에는 자료형의 범위가 큰 쪽으로 자동 형변환되어   
피연산자의 타입을 일치시킨 후에 비교한다.

## 대소비교 연산자 > < >= <=
|비교연산자|연산결과|
|----------|--------|
|>|좌변 값이 크면, true or false|
|<|좌변 값이 작으면, true or false|
|>=|좌변 값이 크거나 같으면, true or false|
|<=|좌변 값이 작거나 같으면, true or false|

## 등가비교 연산자 == !=
|비교연산자|연산결과|
|----------|--------|
|==|두 값이 같으면 true or false|
|!=|두 값이 다르면, true or false|
'='는 변수의 값을 저장할 때 사용하는 '대입연산자'이기 때문에 '=='로 두 값이 같은지 비교하는 연산자를 표현한다.

## 문자열 비교
두 문자열을 비교할 때는, 비교연산자 '==' 대신 equals()라는 메서드를 사용해야 한다.
```java
String str = new String("abc");

boolean result = str.equals("abc"); // 내용이 같으므로 result에 true가 저장됌

boolean result2 = str.equals("abc"); // 같은 내용이지만 다른 객체이기 때문에 false이다.
```
* 원래 String은 클래스이므로, 아래와 같이 new를 사용해서 객체를 생성해야 한다.
```java
String str = new String("abc");     // String 클래스의 객체를 생성
String str = "abc"                  // 위의 문장을 간단히 표현
```
그러나 특별히 String만 new를 사용하지 않고, 위와 같이 간단히 쓸 수 있게 허용된다.   
자세한 내용은 9장에 설명되어 있다.

## 논리 연산자 &&, ||, !
- && : 그리고(AND)에 해당하며, 두 피연산자가 모두 true 일 때만 true 결과로 얻는다.
- || : 또는(OR)에 해당하며, 두 피연산자 중 어느 한쪽만 true여도 true 결과로 얻는다.
- 논리연산자는 피연산자로 boolean형 또는 boolean 형 값을 결과로 하는 조건식만 혀용한다.

- x는 10보다 크고, 20보다 작다.
```java
10 < x && x < 20
```
- i는 2의 배수 또는 3의 배수이다.
```java
i % 2 == 0 || i % 3 == 0
```
- i는 2의 배수 또는 3의 배수지만 6의 배수는 아니다.
```java
(i % 2 == 0 || i % 3 == 0) && i % 6 !=0
```

## 효율적인 연산(short circuit evalution)
OR 연산 경우 어느 한쪽만 참이여도 참이기 때문에 좌측 피연산자가 true이면 우츨 피연산자의 값은 평가하지 않는다.   
연산결과가 참일 확률이 높은 피연산자를 연산자의 왼쪽에 놓아야 더 빠른 연산결과를 얻을 수 있다.

## 논리 부정 연산자 !
이 연산자는 피연산자가 true이면 false를, false이면 true를 결과로 반환한다. 

```java
ch < 'a' || ch > 'z'
```
문자 ch는 소문자가 아니다. 라는 조건을 위 처럼 쓰기보다 아래처럼 쓰면 알기 쉽다.
```java
!('a' <= ch && ch <= 'z')
```

## 비트연산자 & | ^ ~ << >>
비트 연산자는 피연산자를 비트단위로 논리 연산한다. 피연산자를 이진수로 표현했을 때의 각 자리를   
아래의 규칙에 따라 연산을 수행하며, 피연산자로 실수는 허용하지 않는다. 정수(문자 포함)만 허용된다.
```
| (OR연산자)      피연산자 중 한 쪽의 값이 1이면, 1을 결과로 얻는다. 그 외에는 0을 얻는다.
& (AND연산자)     피연산자 양 쪽이 모두 1이어만 1을 결과로 얻는다. 그 외에는 0을 얻는다.
^ (XOR연산자)     피연산자의 값이 서로 다를 때만 1을 결과로 얻는다. 같을 때는 0을 얻는다.
```


## 그 외 연산자
## 조건 연산자 ? :
조건 연산자는 조건식, 식1, 식2 모두 3개의 피연산자를 필요로 하는 삼항 연산자이며, 삼항 연산자는 조건 연산자는 하나뿐이다.
```java
조건식 ? 식1 : 식2
// 참이면 식1 거짓이면 식2

result = (x > y) ? x : y;
```
조건 연산자는 조건문인 if문으로 바꿔 쓸 수 있으며, if문 대신 조건 연산자를 사용하면 코드를 보다 간단히 할 수 있다.
```java
result = (x > y) ? x : y;

->

if (x > y)
   result = x; // true 일떄
else
   result = y; // false 일때
```

## 대입연산자 = op=
대입 연산자는 변수와 같은 저장공간에 값 또는 수식의 연산 결과를 저장하는데 사용된다.   
이 연산자는 오른쪽 피연산자의 값을 왼쪽 피연산자에 저장한다. 그리고 저장된 값을 연산결과로 반환한다.
```java
System.out.print(x = 3); // 변수 x에 3이 저장되고
System.out.print(3); // 연산결과인 3이 출력된다.
```
대입연산자는 연산자들 중에서 가장 낮은 우선순위를 가지고 있기 때문에 식에서 제일 나중에 수행된다.   
연산 진행 방향이 오른쪽에서 왼쪽이기 떄문에 'x=y=3'에서 'y=3'이 먼저 수행되고 그 다음에 'x=y'가 수행된다.

### lvalue 와 rvalue
대입 연산자의 왼쪽 피연산자를 'lvalue'라고 하고, 오른쪽 피연산자를 'rvalue'라고 한다.   
대입연산자의 rvalue는 변수뿐만 아니라 식이나 상수 등 모두 가능한 반면, lvalue는 반드시 변수처럼 값을   
변경할 수 있는 것이어야 한다. 그래서 리터럴이나 상수같이 값으 저장할 수 없는 것들은 lvalue가 될 수 없다.
```java
int i = 0;
3 = i + 3; // 에러. lvalue가 값을 저장할 수 있는 공간이 아니다.
i + 3 = i; // 에러. lvalue의 연산결과는 리터럴

final int MAX = 3; // 변수 앞에 키워드 final을 붙이면 상수가 된다.
MAX = 10; // 에러. 상수 (MAX)에 새로운 값이 저장될 수 없다.
```

### 복합 대입 연산자
대입연산자는 다른 연산자(op)와 결합하여 'op='와 같은 방식으로 사용될 수 있다.   
결합된 두 연산자는 반드시 공백없이 붙여 써야 한다.
| op= | = |
|-----|---|
|i += 3;| i = i + 3;|
|i -= 3;|i = i - 3;|
|i *= 3;|i = i * 3;|
|i /=3;|i = i / 3;|
|i %= 3;|i = i % 3;|
|i <<= 3;|i = i << 3;|
|i >>= 3;|i = i >> 3;|
|i &= 3;|i = i & 3;|
|i ^= 3;|i = i ^ 3;|
|i *= 10 + j;|i = i * (10 + j);|
   
i |= 3; i = i | 3;

* 비트연산자 마무리 못함
